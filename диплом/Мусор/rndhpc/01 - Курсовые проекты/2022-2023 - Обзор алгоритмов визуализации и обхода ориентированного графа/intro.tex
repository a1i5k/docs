%----------------------------------------------------------
\chapter*{ВВЕДЕНИЕ}\label{chap.introduction}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Применение ориентированных графов очень удобно для построения архитектур процессов обработки данных (как в автоматическом, так и в автоматизированном режимах). Вместе с тем многочисленные возникающие в инженерной практике задачи предполагают проведение повторяющихся в цикле операций. Самым очевидным примером является задача автоматизированного проектирования (АП). Эта задача предполагает, как правило, постановку и решение некоторой обратной задачи, которая в свою очередь, часто, решается путём многократного решения прямых задач. Простым примером являются задачи минимизации некоторого функционала невязки при варьирование параметров объекта проектирования. Каждая итерация сопряжена с решением прямой задачи и сравнением численного результата с требуемым (например, известным из эксперимента). Функционал строят согласно заданному критерию оптимизации. 

Необходимо отметить, что прямые задачи (в различных областях) решаются одними методами, тогда как обратные - другими. Эти процессы могут быть очевидным образом отделены друг от друга за счет применения единого уровня абстракции, обеспечивающего определение интерпретируемых архитектур  алгоритмов, реализующих методы решения как прямой, так и обратной задач. Очевидным способом реализации такого уровня абстракции стало использование ориентированных графов.

Для решения подзадачи визуализации графа необходимо определить, что известно о графе, который будет применяться. Дан ориентированный граф, возможно содержащий циклы и селекторы, так же переходы из узла самого в себя.

Для визуализации графов существует 2 способа визуализации графов:
\begin{enumerate}
\item Силовые алгоритмы визуализации графов - расположить узлы графа так, чтобы все рёбра имели более-менее одинаковую длину, и свести к минимуму число пересечений рёбер путём назначения сил для множества рёбер и узлов основываясь на их относительных положениях, а затем путём использования этих сил либо для моделирования движения рёбер и узлов, либо для минимизации их энергии.

\item Послойное рисование графа - это способ, в котором вершины ориентированного графа рисуются горизонтальными рядами или слоями с рёбрами, преимущественно направленными вниз.

\end{enumerate}

Для размещения графов известны силовые алгоритмы следующих типов\cite{alg-graph}:
\begin{itemize}
\item Force-Directed - вершины представляются как заряженные частицы, которые отталкивают друг друга с помощью физической силы, а рёбра — как упругие струны, которые стягивают смежные вершины
\item Multidimensional scaling - вершины являются силой, а рёбра уже являются пружинами
\item Energy-Based - в этом подходе пытаются описать потенциальную энергию системы и найти положение вершин, которое будет соответствовать минимуму
\end{itemize}

Для решения поставленной задачи не имеет значения к какой категории принадлежит исследуемый алгоритм, поэтому необходимо рассмотреть самые часто упоминаемые, а именно: Fruchterman-Reingold, Алгоритм Идеса, Kamada Kawaii, Force Atlas 2, OpenOrd, Гамма – алгоритм.

Чтобы выбрать нужный для данного случая алгоритм необходимо выделить свойства результирующего графа, по котором будет произведён отбор:
\begin{itemize}
\item Граф является ориентированным
\item Конец графа должен находится в противоположной стороне от начала
\item Максимально допустимый граф является среднего размера
\item В графе могут не иметься циклы
\end{itemize}

В алгоритме Fruchterman-Reingold используется пружинная физическая модель, где вершины определяются как тела системы, а ребра как пружины. Силы могут действовать только на вершины, вес пружин при этом не учитывается. Данные алгоритм не подходит, так как он не предусмотрен для ориентированных графов \cite{alg-fruchterman}.

Алгоритм Kamada Kawaii похож на алгоритм Fruchterman-Reingold, но выбирается вершина, на которую действует максимальная сила, затем остальные вершины фиксируются, энергия системы минимизируется. Данный метод не подходит, так как имеет самую высокое время работы из рассматриваемых - $O(V^3)$ \cite{alg-kamada-kawai}.

Force Atlas 2 представляет граф в виде металлических колец, связанных между собой пружинами. Деформированные пружины приводят систему в движение, она колеблется и в конце концов принимает устойчивое положение. Основная его задача - визуализация графов, в которых имеются подмножества с высокой степенью взаимодействия, таким свойством целевой граф не обладает \cite{alg-force-atlas-2}.

OpenOrd - это алгоритм, специально предназначенный для очень больших сетей, который работает на очень высокой скорости при средней степени точности. Это хороший компромисс для больших сетей, но часто он нежелателен для небольших графов где потеря точности может быть значительной по сравнению с другими подходами к компоновке. Все вершины изначально помещаются в начало координат, а затем проводятся итерации оптимизации. Итерации контролируются через алгоритм имитации отжига. Предназначен для визуализации больших графов \cite{alg-open-ord}, следовательно не подходит для целевого графа, так как он является графом маленького или среднего размера.

Гамма - алгоритм основная идея которого заключается в том, что выделяются сегменты, затем в минимальном выделяется цепь, которая укладывается в любую грань, вмещающую данный сегмент \cite{alg-gamma}. Не подходит, так как в целевом графе может не оказаться циклов.

Алгоритм Идеса (Magnetic-Spring Algorithm) рёбра назначаются магнитной пружиной, и затем при воздействии магнитных полей вершины перемешаются \cite{alg-eades}. Лучше всего для целевого графа.

Для любого из способа существуют графы, при визуализации которых может появиться неудовлетворительный вид. Однако в следствии того, что послойное рисование графа представляет более привычный вид ориентированного графа был выбран алгоритм из этого типа. Исходя из этого для решения задачи визуализации графа, бы выбран алгоритм dot.

Алгоритм состоит из 4 этапов - \textsf{rank}, \textsf{ordering}, \textsf{position}, \textsf{make-splines}.

В первом этапе каждому узлу необходимо определить ранг для всех узлов. Определение ранга происходит в результате "естественного" обхода. Наличие циклов не позволяет корректно пройтись по графу, поэтому необходимо разорвать циклы. Разрываются они через использование алгоритма DFS, после для каждого узла уже рассчитывается ранг.

После присвоения ранга, ребра между узлами, которые отличаются на более чем на один ранг заменяются цепочками ребер единичной длины между временными или «виртуальными» узлами. Виртуальные узлы размещаются на промежуточных рангах, превращая исходный граф в граф, ребра которого соединяют только узлы на соседних рангах. Порядок вершин в рангах определяет количество пересечений ребер, поэтому хорошим порядком является тот, который имеет наименьшим количеством пересечений. 

Третий проход является этап корректировки. Он нужен для того, чтобы избежать плохих расположений узлов графа. Координаты X и Y вычисляются в два отдельных шага. На первом этапе всем узлам (включая виртуальные узлы) присваиваются координаты X в соответствии с уже определенным порядком внутри рангов. На втором этапе назначаются координаты Y, присваивая одинаковое значение узлам одного ранга. 

После этого в последнем этапе определяются и рисуются ребра, которые будут представлены в виде сплайна. Алгоритм попытается найти самую гладкую кривую между двумя точками, которая избегает «препятствий» в виде других узлов или сплайнов. Затем разделит алгоритм маршрутизации сплайнов на верхнюю половину и нижнюю половину. Верхняя половина вычисляет многоугольную область макета, где может быть нарисован сплайн. Она вызывает нижнюю половину для вычисления наилучшего сплайна в области\cite{alg-dot}.

Для решения задачи обхода графа из-за специфичности задачи было принято решение о создании собственного алгоритма. Особенностями больше всего влияющие на решение создания алгоритма являются - наличие селекторов, проход не всегда по всему графу.

Далее при описании алгоритма используется терминология, введённая в работах \cite{SokPersh2019PCS, SokGolub2021GBSEBL}.

Рассмотрим некоторый узел $S_i$ орграфа $G$, из которого выходит множество рёбер $E_i=\{e_{ij}\}_1^n$, $n>0$. Для построения алгоритма обхода необходимо определить правила перехода от узла $S_{i}$ к другим узлам.
\begin{enumerate}
  \item Если $n=1$, то переход безусловный, т.е. предполагает вызов связанной с $e_{ij}$ функции перехода $F_{ij}$, где $j$ соответствует номеру следующего узла $S_j$.
  \item Если $n>1$, то переход следует осуществлять по всем рёбрам, которые определяются с помощью функции-селектора $h_i$ (организует ветвление, рис.~\ref{rndhpcedt.20230201.1}), сопоставленной с узлом $S_i$, результат выполнения которой определяет подмножество $\hat{E}_i=\{a_{ik}\colon {a_{ik}\in E_i}, {\pr_k(h_i(D_i))=1}, {D_i \filledemptyspoon S_i}\}$, где $S_i$ -- состояние данных \gls{ccm}, сопоставленное с одноимённым узлом $S_{i}$, $D_i$ -- данные в состоянии $S_i$, $\pr_{i}(r)$ -- операция проекции объекта $r$ на $i$-ю координату. Порядок выбора рёбер из $\hat{E}_i$ для осуществления перехода не важен.
\end{enumerate}

\begin{remark}
Реализация $\hat{E}_i$ для каждого $i$ возможна путём формирования структуры данных стек. Заполнение соответствующего стека элементами может быть осуществлено в произвольном порядке\footnote{Должны быть выполнены все функции перехода $F_{ij}$, связанные с соответствующими рёбрами, в произвольном порядке (возможно в многопоточном режиме).}.
\end{remark}

Для реализации требуемого алгоритма необходимо: сделать класс дуги и в класс узла добавить поля, которые определяют необходимое число для перехода через данный узел и количество дуг, которые уже пришли в узел. Класс дуги содержит два поля: начальный узел и конечный узел.

Рассмотрим работу алгоритма на примере орграфа, представленного на рисунке~\ref{fig:graph}. Начальная вершина называется \textsf{Start}, а конечная \textsf{End}. Селекторы в данном примере отсутствуют.

Рассмотрим алгоритм перехода из узла \textsf{Start}. Так как из узла \textsf{Start} выходит два ребра, то выбираем случайное из них (например, ребро \textsf{Start$\rightarrow$A}), совершаем соответствующий переход\footnote{Выполняем соответствующую функцию перехода при \flqq боевом \frqq режиме обхода.}, тогда как оставшееся ребро \textsf{Start$\rightarrow$B} заносится в стек. После перехода в \textsf{A}.  Затем из-за того, что всего доступна только одна вершина, переход происходит в вершину \textsf{C}.

Далее происходит ситуация, что из вершины опять выходит два ребра. Аналогичным образом для перехода выбираем, например, ребро \textsf{C$\rightarrow$E}, тогда в стек заносится ребро \textsf{C$\rightarrow$F}. После выполнения перехода в вершину \textsf{E} ещё раз необходимо выполнение таких же действий. Допустим переход осуществляется по ребру \textsf{E$\rightarrow$D}, а \textsf{E$\rightarrow$G} заносится в стек. На текущий момент в стеке находится три ребра - \textsf{Start$\rightarrow$B}, \textsf{C$\rightarrow$F}, \textsf{E$\rightarrow$G}.

После выполнения перехода в вершину \textsf{D} оказывается, что она требует для продолжения выполнение перехода ещё по ребру \textsf{B$\rightarrow$D}. Следовательно, из стека достаётся ребро - \textsf{E$\rightarrow$G} и осуществляется переход по данному ребру. Далее, при попытке переход через вершину \textsf{G} получается, что необходимо выполнения ребра \textsf{D$\rightarrow$G}, достаётся следующее ребро из стека. Далее выполняется переход по ребру \textsf{C$\rightarrow$F}. Аналогично переход по ребру \textsf{F$\rightarrow$H}. Далее вершина \textsf{H} для продолжения обхода требует переход по \textsf{G$\rightarrow$H}. Из-за этого берется ребро из стека и выполняется переход по нему.

Затем, после перехода по ребру \textsf{B$\rightarrow$D}, в вершине \textsf{D} проверяется разрешается ли переход далее. Так как все нужные для продолжения обхода ребра уже пройдены, то переход разрешается. Далее из этой вершины по ребру \textsf{D$\rightarrow$G} осуществляется переход. В вершине \textsf{G} повторяется аналогичная ситуация, поэтому осуществляется переход по ребру \textsf{G$\rightarrow$H}. Далее по такому же правилу алгоритм доходит до вершины \textsf{End}, чем заканчивает обход.

В разработанном А.П.~Соколовым и А.Ю.~Першиным графоориентированном программном каркасе, для описания графовых моделей был разработан формат aDOT, который является расширением формата описания графов DOT.

Для визуализации графов, описанных с использованием формата DOT, используются специальные программы визуализации. Формат aDOT расширяет формат DOT с помощью дополнительных атрибутов и определений, которые описывают функции-предикаты, функции-обработчики и функции-перехода в целом. Из этого вытекает, что для построения графовых моделей с использованием формата aDOT необходим графический редактор.